console.log("Welcome to RedHanded")


const LHS = "(define tau 6.28)\n\n(define (sum-both-nat n m)\n  (if (or (< n 0) (< m 0))\n      \"bad\"\n      (+ n m)))\n"
const RHS = "(define (sum-both-nat n m)\n  (if (or (< n 0) (< m 0))\n      \"bad\"\n      (+ n m)))\n\n(define tau 6.28)\n";

/**
 * Represents the location information that can be found in certain 
 * AST-nodes (added during the parsing phase). 
 * -- "start" is the start location information for the node
 * -- "end" is the end location information for the node
 */
// export type Loc = {
//   start: LocPos,
//   end: LocPos
// }

/**
 * -- The "offset" property contains an offset as a zero-based 
 *    index and 
 * -- "line" and "column" properties contain a line and a
 *    column as one-based indices.
 */
// export type LocPos = {
//   offset: number,
//   line: number,
//   column: number
// }

// export type ProgramPairLocs = {
//   lhs_locs: Loc[],
//   rhs_locs: Loc[]
// }

// export type ProgramStrPair = {
//   lhs_str: string,
//   rhs_str: string,
// }



/**
 * Represents the result generated by the plagiarism algorithm. 
 * -- "type" is the kind of plagiarism detected
 * -- "Loc" represents a series of location information
 * -- "similarity" is a number denoting the similarity %
 */
// export type CopyInfo = {
//   type: string,
//   loc: [Loc, Loc][],
//   similarity: number
// }

// lhs_rhs_loc_info(programStrPair: ProgramStrPair): ProgramPairLocs
const LHS_RHS_LOC_INFO = {
  "lhs_locs":
      [{
        "start":{"offset":0,"line":1,"column":1},
        "end":{"offset":17,"line":1,"column":18}},
      { "start":{"offset":19,"line":3,"column":1},
        "end":{"offset":100,"line":6,"column":16}}],
  "rhs_locs":
      [{"start":{"offset":0,"line":1,"column":1},
      "end":{"offset":17,"line":1,"column":18}},
      {"start":{"offset":19,"line":3,"column":1},
      "end":{"offset":100,"line":6,"column":16}}]
}

// get_copy_info(programStrPair: ProgramStrPair): CopyInfo
const COPY_INFO = { "type": "moving code", 
"loc": [[{ 
      "start": { "offset": 0, "line": 1, "column": 1 }, 
      "end": { "offset": 17, "line": 1, "column": 18 } }, { 
      "start": { "offset": 0, "line": 1, "column": 1 }, 
      "end": { "offset": 17, "line": 1, "column": 18 } }], 
      
      [{ "start": { "offset": 19, "line": 3, "column": 1 }, 
      "end": { "offset": 100, "line": 6, "column": 16 } }, 
      { "start": { "offset": 19, "line": 3, "column": 1 }, 
      "end": { "offset": 100, "line": 6, "column": 16 } }]], "similarity": 100 }


function onloadfunction() {

  document.getElementById("inputlhs").innerHTML = "(define x 1)";
  document.getElementById("inputrhs").innerHTML = "(define x 2)";

  console.log("loaded")
}

document.getElementById("submitbtn").addEventListener("click", function () {

  console.log("button clicked!")


  let lhs = document.getElementById("inputlhs").value
  console.log("value of input lhs")
  console.log(lhs);


  let rhs = document.getElementById("inputrhs").value
  console.log("value of input rhs")
  console.log(rhs);


  algorithm({ lhs: lhs, rhs: rhs }, display)


})

function actualAgorithm(i) {
  return {
    lhs: i.lhs + "REDHANDED",
    rhs: i.rhs + "REDHANDED"
  }
}


function algorithm(i, clb) {
  clb(actualAgorithm(i))
}


function display(res) {
  let inputlhs = document.getElementById("inputlhs");
  let inputrhs = document.getElementById("inputrhs");
  document.getElementById("displaylhs").innerHTML = res.lhs;
  document.getElementById("displayrhs").innerHTML = res.rhs;
  highLightLocs(inputlhs, inputrhs);
}

function generateRandomColor() {

  const randomColor = Math.floor(Math.random()*16777215).toString(16);
    document.body.style.backgroundColor = "#" + randomColor;
    color.innerHTML = "#" + randomColor;

}


function highLightLocs(lhs, rhs) {
  let pair = new ProgramStrPair(lhs, rhs);

  let locs = lhs_rhs_loc_info(pair); // returns ProgramPairLocs
  let matches = get_copy_info(pair); // returns CopyInfo

  for(let i = 0; i < locs; i++) {
    matches.loc[i][0].start.offset
    if(matches.loc.indexOf(locs.lhs_locs[i]) != -1) {
      <span id="i">lhs_as_string</span> 
    } else {
      <span>lhs_as_string</span>
    }
  }
}

/**
 * 
 * /**
 * Represents the result generated by the plagiarism algorithm. 
 * -- "type" is the kind of plagiarism detected
 * -- "Loc" represents a series of location information
 * -- "similarity" is a number denoting the similarity %
 */
// export type CopyInfo = {
//   type: string,
//   loc: [Loc, Loc][],
//   similarity: number
// }
// get_copy_info(programStrPair: ProgramStrPair): CopyInfo
// const COPY_INFO = { "type": "moving code", "loc": [[{ "start": { "offset": 0, "line": 1, "column": 1 }, "end": { "offset": 17, "line": 1, "column": 18 } }, { "start": { "offset": 0, "line": 1, "column": 1 }, "end": { "offset": 17, "line": 1, "column": 18 } }], [{ "start": { "offset": 19, "line": 3, "column": 1 }, "end": { "offset": 100, "line": 6, "column": 16 } }, { "start": { "offset": 19, "line": 3, "column": 1 }, "end": { "offset": 100, "line": 6, "column": 16 } }]], "similarity": 100 }
function get_copy_info(pair) {
    return COPY_INFO;
}

// lhs_rhs_loc_info(programStrPair: ProgramStrPair): ProgramPairLocs
// const LHS_RHS_LOC_INFO = {
//   "lhs_locs":[{"start":{"offset":0,"line":1,"column":1},"end":{"offset":17,"line":1,"column":18}},{"start":{"offset":19,"line":3,"column":1},"end":{"offset":100,"line":6,"column":16}}],
//   "rhs_locs":[{"start":{"offset":0,"line":1,"column":1},"end":{"offset":17,"line":1,"column":18}},{"start":{"offset":19,"line":3,"column":1},"end":{"offset":100,"line":6,"column":16}}]
// }
function lhs_rhs_loc_info(pair) {
    return LHS_RHS_LOC_INFO;
}



/**

[1]
(define (sum-both-nat n m)
  (if (or (< n 0) (< m 0))
      "bad"
      (+ n m)))

[2]
(define tau 6.28)


LOC-1
LOC-2


<span id="1">1-as-string<span>
<span id="2">2-as-string<span>

FOLLOW this algo::::>>>



divide the program into deffinitions/expressions LOCS
for each loc, make a <span>
add ID to span by index.

only color spans with matching IDS.





lhsProgStr //
rhsProgStr //

LocationsToHighLight in LHS
LocationsToHighLight in RHS



let locs = [LOC, LOC][]
let locationsToColor = locs.length


let colorsList = genColors(locationsToColor)


// SO = get start offfset
// EO = get end offset

from the colorList, pick corresponding color, and
COLOR the substring in LHS/RHS starting SO, ending EO





 type Loc = {
  start: {
    offset: number,
    line: number,
    column: number
  },
  end: {
    offset: number,
    line: number,
    column: number
  }
}

  */





  /**
  
  
lhs_as_string

let X =  LOC[] representing the location information for each top-level definition in lhs_as_string




lhs_as_string, rhs_as_string


let Y = [LOC, LOC][] representing similarities to display




create X spans by color Y of them.

*/
